[ホームに戻る](./index.md)  
←　[第４話](AnalogIn_explain.md)　｜　[第６話](comunication.md)　→  

# 割り込み処理を活用しよう
　今回の記事では、マイコンプログラミングにおいて重要な「割り込み処理」について説明します。あまり聞き馴染みのない言葉だとは思いますが、
**ステッピングモーターの回転**、**エンコーダーの利用**、**マイコン間通信**、**並行処理**など、様々なところで活用します。
　
　少しボリューミーになると思いますが、是非習得してください。

# 割り込み処理とは
　割り込みとは、「特定の条件のときに、平時の処理を中断して、別の処理（割り込み処理）を行う」というものです。Mbedでは、主に３種類の「条件」に対応する割り込み処理のクラスが存在しています。

* タイマー割り込み
* ピン変化割り込み
* 通信割り込み

の３種類です。この記事では前半２つを解説します。「通信割り込み」は通信の記事で取り扱うので [第６話](comunication.md) を参照してください。

# タイマー割り込み (Ticker)
　タイマー割り込みは、一定周期で処理を割り込ませることができます。ピンと来ないと思うので、早速以下のサンプルプログラムを作ってみましょう。
LEDを２つ、タクトスイッチを一つ用意して、一方は１秒周期で点滅、もう一方はボタンが押されるまで待機し、押されたら点灯するようなプログラムを作ります。
LEDに抵抗をつなげるのもお忘れなく‼

``` cpp
#include <mbed.h>

Ticker tick_sample;
DigitalOut myled1(PA_1);
DigitalOut myled2(PA_2);
DigitalIn my_sw(PA_0);

void warikomi()
{
    myled2 = !myled2;
    //点灯していたら(myled2.read()がtrue)、falseにする。逆も同様
}

int main()
{
    tick_sample.attach(&warikomi,500000);
    //下がメインの処理
    myled1.write(0);
    while(my_sw.read()){/*スイッチがHIGH(オフ)のとき無限ループ*/}
    myled1.write(1);
}

```

さて、想定通り動いたはずです。ここで重要なのは、**main関数内の処理が待機中であるにもかかわらず、点滅させることができている点です**。このように、タイマー割り込みは**並列で処理させたいとき**や、**最初から最後まで一定周期で処理を行いたいとき**に使用します。また、タイマー割り込みの仕様を理解した後だと
**コードがシンプルになる**というメリットもあります。

## Tickerの使い方
　Tickerの使い方を解説します。詳しく知りたい人は [こちら](https://os.mbed.com/docs/mbed-os/v6.15/mbed-os-api-doxy/classmbed_1_1_ticker.html)からレファレンスを読んでください。
　Tickerでは、n マイクロ秒ごとに関数を呼び出す、という形でタイマー割り込みを実行します。なので、予め割り込ませたい処理を関数にしておいてください。

``` cpp
Ticker tick_sample;
```
例によってインスタンス化です。特に言うことはないです。

``` cpp
tick_sample.attach(&warikomi,500000);
```
これでタイマー割り込みをセットします。このコードが読み込まれた後、タイマー割り込みが始まります。
書き方は`インスタンス名.attach(&呼び出す関数名,呼び出す周期 [ms]);`です。
`&呼び出す関数名`は恐らく初めて見る書き方だと思いますが、これは**関数のポインタ**と呼ばれるものです。
簡単に言えば、Tickerクラスのattachという関数に、タイマーで繰り返し使いたい関数がコンピュータ上のどこに保存されているのかを教えているのです。

ちなみに、割り込みを解除するときは、
``` cpp
tick_sample.detach();
```
というように、`インスタンス名.detach()`と書いてください。これでオフになります。

# ピン変化割り込み（InterruptIn）
では次に、**ピン変化割り込み**について紹介します。ピン変化割り込みとは、その名の通り、**そのピンにかかっている電圧が変化したとき**に処理を割り込ませるものです。
これを使って、LED点滅プログラムを緊急停止させるプログラムを書いてみましょう。
タクトスイッチを一つ使って回路を組みます。マイコンの適当なピンとGNDにブザーを接続してください。タクトスイッチはPA_0ピンに接続しましょう。

以下のようなプログラムを書いてみましょう。
``` cpp
#include <mbed.h>

InterruptIn emergence_sw(PA_0,PullUp);
DigitalOut　myled(LED1);

bool emergence_flag = false;

void emergence_callback()
{
    emergence_flag != emergence_flag;
}

int main()
{
    myled = 0;
    emergence_sw.fall(&emergence_callback);

    while(1)
    {
        if(!emergence_flag)
        {
            myled = 1;
        }
        wait_us(100000);
        myled = 0;
        wait_us(100000);
    }
}
```

プログラムが完成したら、書き込んでみましょう。想定通りに動くはずです。
こちらも注目すべきは、`while`文内部にボタンが押されたか否かの判定の処理が書いていないことです。

# 解説
ではソースコードの解説をしていきます。
``` cpp
InterruptIn emergence_sw(PA_0,PullUp)
```
`InterruprIn`クラスのインスタンス化は、`DigitalIn`や`AnalogIn`の時とほぼ同じです。
今回は、プルアップ抵抗の回路を外部に作るのが面倒だったので、コンストラクタの第二引数として`PullUp`を渡すことでマイコン内部のプルアップ抵抗を使用しています。同様の機能は`DigitalIn`や`AnalogIn`にもあります。

``` cpp
void emergence_callback()
{
    emergence_flag != emergence_flag;
}
```
割り込みで呼び出す関数の定義です。emergence_flagを緊急停止が発動していればTrueになるbool型として機能させています。`!=`演算子によってbool型の変数の真偽を反転できるのは復習ポイントです。

``` cpp
emergence_sw.fall(&emergence_callback);
```
これがピン変化割り込みをセットするのに必要なコードです。`インスタンス名.fall(&呼び出す関数);`と書くと、指定したピンにかかる電圧がHIGH(3.3 V)からLOW(0 V)に下がった(=fall)時に関数を呼び出します。
今回は使いませんでしたが、`インスタンス名.rise(&呼び出す関数);`と書くとピンにかかる電圧がLOWからHIGHに上がった(=rise)時に関数を呼び出すこともできます。

# 割り込み処理の注意点
割り込み処理を使うにあたって、いくつか注意点があります。これは次回説明する通信割り込みにも当てはまります。

## 呼び出す関数は返り値を持ってはいけない
割り込み処理で関数を呼び出すとき、返り値を格納する変数がありませんので、**当然void型の関数しか呼び出せません**。割り込み処理である変数の値を変更したいときは、その変数をグローバル変数にするか、ポインタを使いましょう。

## 呼び出す関数で計算量の多い処理をしない
初めに説明したように、割り込み処理は特定の条件で「**平時の処理を中断して**」処理を行う機能です。
そのため、時間のかかる処理（回数の多いループ処理、通信 等）を割り込みで呼び出す関数にやらせようとすると、様々な不具合が起こる可能性があります。
例えば、`Ticker`を使って1 msおきに行う処理が2 msかかる処理だったら、当然ですがプログラムがバグってしまいます。ピン変化割り込みの処理中にまたピン変化が起こったら、これもバグのもとになります。
割り込みで呼び出す関数では、**変数の代入などの簡単な処理**のみを書くことをお勧めします。

# おまけ：割り込み処理のどこが美味しいの？
今回の記事では、割り込み処理について紹介してきました。しかし、`Ticker`も`InterruptIn`もそれ以前に紹介した機能で再現できそうだと思った方はいませんか？例えば、「`while`文で十分速い周期で`DigitalIn`でピンの様子を読めば`InterruptIn`を使わずに済むのではないか？」などと思いはしませんでしたか？
確かに`InterruptIn`は`DigitalIn`と`While`文を使って再現可能です。しかし、`InterruptIn`にはきちんとした利点があります。それは、「マイコン側が割くリソースが少ない」という点です。`InterruptIn`はマイコンのCPUではなく、CPUの機能を拡張する周辺機器(ペリフェラル)に実装されている機能です。`InterruptIn`を使うことで、CPUの割かなければいけないリソースを低減できるわけです。
ペリフェラルが何なのか簡単に知りたい人は、[こちら](https://emb.macnica.co.jp/articles/14446/)のサイトなどを読んでみてください。


←　[第４話](AnalogIn_explain.md)　｜　[第６話](comunication.md)　→  
[ホームに戻る](./index.md)